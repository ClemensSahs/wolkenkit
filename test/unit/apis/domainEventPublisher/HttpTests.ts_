import { ApplicationDefinition } from '../../../../lib/common/application/ApplicationDefinition';
import { asJsonStream } from '../../../shared/http/asJsonStream';
import assert from 'assertthat';
import { buildDomainEvent } from '../../../shared/buildDomainEvent';
import { DomainEvent } from '../../../../lib/common/elements/DomainEvent';
import { DomainEventData } from '../../../../lib/common/elements/DomainEventData';
import eventFilter from '../../../shared/applications/valid/eventFilter';
import { eventIsAuthorized } from '../../../shared/applications/valid/eventIsAuthorized';
import { eventMap } from '../../../shared/applications/valid/eventMap';
import { DomainEventStore } from '../../../../lib/stores/domainEventStore/DomainEventStore';
import { getApplicationDefinition } from '../../../../lib/common/application/getApplicationDefinition';
import { getApplicationDescription } from '../../../../lib/common/application/getApplicationDescription';
import { Http } from '../../../../lib/apis/domainEventPublisher/Http';
import { identityProvider } from '../../../shared/identityProvider';
import { InMemoryDomainEventStore } from '../../../../lib/stores/domainEventStore/InMemory/InMemoryDomainEventStore';
import path from 'path';
import record from 'record-stdstreams';
import { Repository } from '../../../../lib/common/domain/Repository';
import { sleep } from '../../../../lib/common/utils/sleep';
import uuid from 'uuidv4';
import supertest, { Response } from 'supertest';

suite('event/Http', (): void => {
  const identityProviders = [ identityProvider ];
  let applicationDefinition: ApplicationDefinition,
      domainEventStore: DomainEventStore,
      repository: Repository;

  setup(async (): Promise<void> => {
    const applicationDirectory = path.join(__dirname, '..', '..', '..', 'shared', 'applications', 'base');

    domainEventStore = await InMemoryDomainEventStore.create();

    applicationDefinition = await getApplicationDefinition({ applicationDirectory });
    repository = new Repository({ applicationDefinition, domainEventStore });
  });

  teardown(async (): Promise<void> => {
    await domainEventStore.destroy();
  });

  suite('initialize', (): void => {
    test('sets api to an Express application.', async (): Promise<void> => {
      const http = await Http.create({
        corsOrigin: '*',
        applicationDefinition,
        repository,
        identityProviders
      });

      assert.that(http.api).is.ofType('function');
    });
  });

  suite('CORS', (): void => {
    const corsOrigins = [
      {
        title: 'returns * if anything is allowed.',
        origin: 'http://www.thenativeweb.io',
        allow: '*',
        expected: '*'
      },
      {
        title: 'returns origin if origin is allowed.',
        origin: 'http://www.thenativeweb.io',
        allow: 'http://www.thenativeweb.io',
        expected: 'http://www.thenativeweb.io'
      },
      {
        title: 'returns origin if origin is allowed by a regular expression.',
        origin: 'http://www.thenativeweb.io',
        allow: /\.thenativeweb\.io$/u,
        expected: 'http://www.thenativeweb.io'
      },
      {
        title: 'returns origin if origin is one of multiple allowed.',
        origin: 'http://www.thenativeweb.io',
        allow: [ 'http://www.thenativeweb.io', 'http://www.example.com' ],
        expected: 'http://www.thenativeweb.io'
      },
      {
        title: 'returns undefined if origin is not allowed.',
        origin: 'http://www.example.com',
        allow: 'http://www.thenativeweb.io',
        expected: undefined
      },
      {
        title: 'returns undefined if origin is not allowed by a regular expression.',
        origin: 'http://www.example.com',
        allow: /\.thenativeweb\.io$/u,
        expected: undefined
      }
    ];

    for (const corsOrigin of corsOrigins) {
      /* eslint-disable no-loop-func */
      test(corsOrigin.title, async (): Promise<void> => {
        const http = await Http.create({
          corsOrigin: corsOrigin.allow,
          applicationDefinition,
          repository,
          identityProviders
        });

        await supertest(http.api).
          options('/').
          set({
            origin: corsOrigin.origin,
            'access-control-request-method': 'POST',
            'access-control-request-headers': 'X-Requested-With'
          }).
          expect((res: Response): void => {
            assert.that(res.status).is.equalTo(200);
            assert.that(res.header['access-control-allow-origin']).is.equalTo(corsOrigin.expected);
            assert.that(res.header['access-control-allow-methods']).is.equalTo('GET,POST');
          });
      });
      /* eslint-enable no-loop-func */
    }
  });

  suite('GET /v2/description', (): void => {
    let http: Http;

    setup(async (): Promise<void> => {
      http = await Http.create({
        corsOrigin: '*',
        applicationDefinition,
        repository,
        identityProviders
      });
    });

    test('returns 200.', async (): Promise<void> => {
      await supertest(http.api).
        get('/v2/description').
        expect((res: Response): void => {
          assert.that(res.status).is.equalTo(200);
        });
    });

    test('returns application/json.', async (): Promise<void> => {
      await supertest(http.api).
        get('/v2/description').
        expect((res: Response): void => {
          assert.that(res.header['content-type']).is.equalTo('application/json; charset=utf-8');
        });
    });

    test('serves the domain event description.', async (): Promise<void> => {
      await supertest(http.api).
        get('/v2/description').
        expect((res: Response): void => {
          const domainEventDescription =
            getApplicationDescription({ applicationDefinition }).domainEvents;

          // Convert and parse as JSON, to get rid of any values that are undefined.
          // This is what the HTTP API does internally, and here we need to simulate
          // this to make things work.
          const expectedDomainEventDescription = JSON.parse(JSON.stringify(domainEventDescription));

          assert.that(res.body).is.equalTo(expectedDomainEventDescription);
        });
    });
  });

  suite('GET /v2/', (): void => {
    let http: Http;

    setup(async (): Promise<void> => {
      http = await Http.create({
        corsOrigin: '*',
        applicationDefinition,
        repository,
        identityProviders
      });
    });

    test('delivers a single domain event.', async (): Promise<void> => {
      const executed = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'executed',
        data: { strategy: 'succeed' },
        metadata: {
          revision: { aggregate: 1 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });

      setTimeout(async (): Promise<void> => {
        await http.publishDomainEvent({ domainEvent: executed });
      }, 50);

      await new Promise((resolve, reject): void => {
        try {
          supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
            (domainEvent): void => {
              assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
            },
            (domainEvent): void => {
              assert.that(domainEvent.data).is.equalTo({ strategy: 'succeed' });
              resolve();
            }
          ));
        } catch (ex) {
          reject(ex);
        }
      });
    });

    test('delivers multiple domain events.', async (): Promise<void> => {
      const succeeded = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'succeeded',
        data: {},
        metadata: {
          revision: { aggregate: 1 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });
      const executed = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'executed',
        data: { strategy: 'succeed' },
        metadata: {
          revision: { aggregate: 2 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });

      setTimeout(async (): Promise<void> => {
        await http.publishDomainEvent({ domainEvent: succeeded });
        await http.publishDomainEvent({ domainEvent: executed });
      }, 50);

      await new Promise((resolve, reject): void => {
        try {
          supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
            (domainEvent): void => {
              assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
            },
            (domainEvent): void => {
              assert.that(domainEvent.name).is.equalTo('succeeded');
              assert.that(domainEvent.data).is.equalTo({});
            },
            (domainEvent): void => {
              assert.that(domainEvent.name).is.equalTo('executed');
              assert.that(domainEvent.data).is.equalTo({ strategy: 'succeed' });
              resolve();
            }
          ));
        } catch (ex) {
          reject(ex);
        }
      });
    });

    test('delivers filtered domain events.', async (): Promise<void> => {
      const succeeded = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'succeeded',
        data: {},
        metadata: {
          revision: { aggregate: 1 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });
      const executed = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'executed',
        data: { strategy: 'succeed' },
        metadata: {
          revision: { aggregate: 2 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });

      setTimeout(async (): Promise<void> => {
        await http.publishDomainEvent({ domainEvent: succeeded });
        await http.publishDomainEvent({ domainEvent: executed });
      }, 50);

      await new Promise((resolve, reject): void => {
        try {
          supertest(http.api).
            get('/v2/').
            query({ name: 'executed' }).
            pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                assert.that(domainEvent.data).is.equalTo({ strategy: 'succeed' });
                resolve();
              }
            ));
        } catch (ex) {
          reject(ex);
        }
      });
    });

    test('delivers filtered domain events with a nested filter.', async (): Promise<void> => {
      const succeeded = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'succeeded',
        data: {},
        metadata: {
          revision: { aggregate: 1 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });
      const executed = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'executed',
        data: { strategy: 'succeed' },
        metadata: {
          revision: { aggregate: 2 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });

      setTimeout(async (): Promise<void> => {
        await http.publishDomainEvent({ domainEvent: succeeded });
        await http.publishDomainEvent({ domainEvent: executed });
      }, 50);

      await new Promise((resolve, reject): void => {
        try {
          supertest(http.api).
            get('/v2/').
            query({
              contextIdentifier: { name: 'sampleContext' },
              name: 'executed'
            }).
            pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                assert.that(domainEvent.data).is.equalTo({ strategy: 'succeed' });
                resolve();
              }
            ));
        } catch (ex) {
          reject(ex);
        }
      });
    });

    test('removes annotations before delivery.', async (): Promise<void> => {
      const executed = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'executed',
        data: { strategy: 'succeed' },
        metadata: {
          revision: { aggregate: 1 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });

      setTimeout(async (): Promise<void> => {
        await http.publishDomainEvent({ domainEvent: executed });
      }, 50);

      await new Promise((resolve, reject): void => {
        try {
          supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
            (domainEvent): void => {
              assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
            },
            (domainEvent): void => {
              assert.that(domainEvent.annotations).is.undefined();
              resolve();
            }
          ));
        } catch (ex) {
          reject(ex);
        }
      });
    });

    test('gracefully handles connections that get closed by the client.', async (): Promise<void> => {
      const executed = buildDomainEvent({
        contextIdentifier: { name: 'sampleContext' },
        aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
        name: 'executed',
        data: { strategy: 'succeed' },
        metadata: {
          revision: { aggregate: 1 },
          initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
        }
      });

      try {
        await supertest(http.api).
          get('/v2/').
          timeout({ response: 10, deadline: 10 });
      } catch (ex) {
        if (ex.code !== 'ECONNABORTED') {
          throw ex;
        }

        // Ignore aborted connections, since that's what we want to achieve
        // here.
      }

      await sleep({ ms: 50 });

      await assert.that(async (): Promise<void> => {
        await http.publishDomainEvent({ domainEvent: executed });
      }).is.not.throwingAsync();
    });

    suite('isAuthorized', (): void => {
      test('skips an event if the event is not authorized.', async (): Promise<void> => {
        const directory = await eventIsAuthorized();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const authorizationDenied = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'authorizationDenied',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const executed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: authorizationDenied });
          await http.publishDomainEvent({ domainEvent: executed });
        }, 50);

        await new Promise((resolve, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('skips an event if an error is thrown.', async (): Promise<void> => {
        const directory = await eventIsAuthorized();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const authorizationFailed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'authorizationFailed',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const executed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: authorizationFailed });
          await http.publishDomainEvent({ domainEvent: executed });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('does not mutate the event.', async (): Promise<void> => {
        const directory = await eventIsAuthorized();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const authorizedWithMutation = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'authorizedWithMutation',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: authorizedWithMutation });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('authorizedWithMutation');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        assert.that(authorizedWithMutation.data.isMutated).is.undefined();
      });

      test('uses the app service.', async (): Promise<void> => {
        const directory = await eventIsAuthorized();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });
        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid(),
              otherAggregateId = uuid();

        const otherSucceeded = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: otherAggregateId },
          name: 'succeeded',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const otherExecuted = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: otherAggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        await domainEventStore.saveEvents({
          uncommittedEvents: [ otherSucceeded, otherExecuted ]
        });

        const useApp = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'useApp',
          data: { otherAggregateId },
          metadata: {
            revision: { aggregate: 3 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        const stop = record(false);

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: useApp });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('useApp');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        const { stdout } = stop();
        const message = JSON.parse(stdout);

        assert.that(message).is.atLeast({
          id: otherAggregateId,
          state: {}
        });
      });

      test('uses the client service.', async (): Promise<void> => {
        const directory = await eventIsAuthorized();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const useClient = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
          name: 'useClient',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        const stop = record(false);

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: useClient });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('useClient');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        const { stdout } = stop();
        const message = JSON.parse(stdout);

        assert.that(message).is.atLeast({
          user: {
            id: 'anonymous',
            claims: {
              iss: 'https://token.invalid',
              sub: 'anonymous'
            }
          }
        });
        assert.that(message.ip).is.ofType('string');
        assert.that(message.ip.length).is.atLeast(1);
      });

      for (const logLevel of [ 'fatal', 'error', 'warn', 'info', 'debug' ]) {
        /* eslint-disable no-loop-func */
        test(`uses the logger service with log level '${logLevel}'.`, async (): Promise<void> => {
          const directory = await eventIsAuthorized();

          application = await Application.load({ directory });
          repository = new Repository({ application, domainEventStore });

          http = await Http.create({
            corsOrigin: '*',
            purpose: 'external',
            async onReceiveEvent (): Promise<void> {
              // Intentionally left blank.
            },
            application,
            repository,
            identityProviders
          });

          const useLogger = buildDomainEvent({
            contextIdentifier: { name: 'sampleContext' },
            aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
            name: 'useLogger',
            data: { logLevel },
            metadata: {
              revision: { aggregate: 1 },
              initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
            },
            annotations: { state: {}, previousState: {}}
          });

          const stop = record(false);

          setTimeout(async (): Promise<void> => {
            await http.publishDomainEvent({ domainEvent: useLogger });
          }, 50);

          await new Promise((resolve: (value?: unknown) => void, reject): void => {
            try {
              supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
                (domainEvent): void => {
                  assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
                },
                (domainEvent): void => {
                  assert.that(domainEvent.name).is.equalTo('useLogger');
                  resolve();
                }
              ));
            } catch (ex) {
              reject(ex);
            }
          });

          const { stdout } = stop();
          const message = JSON.parse(stdout);

          assert.that(message).is.atLeast({
            level: logLevel,
            message: 'Some log message.',
            source: path.join(directory, '/server/domain/sampleContext/sampleAggregate.js')
          });
        });
        /* eslint-enable no-loop-func */
      }
    });

    suite('filter', (): void => {
      test('skips an event if the event gets filtered out.', async (): Promise<void> => {
        const directory = await eventFilter();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const filterDenied = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'filterDenied',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const executed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: filterDenied });
          await http.publishDomainEvent({ domainEvent: executed });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('skips an event if an error is thrown.', async (): Promise<void> => {
        const directory = await eventFilter();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const filterFailed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'filterFailed',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const executed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: filterFailed });
          await http.publishDomainEvent({ domainEvent: executed });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('does not mutate the event.', async (): Promise<void> => {
        const directory = await eventFilter();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const filteredWithMutation = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'filteredWithMutation',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: filteredWithMutation });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('filteredWithMutation');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        assert.that(filteredWithMutation.data.isMutated).is.undefined();
      });

      test('uses the app service.', async (): Promise<void> => {
        const directory = await eventFilter();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid(),
              otherAggregateId = uuid();

        const otherSucceeded = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: otherAggregateId },
          name: 'succeeded',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const otherExecuted = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: otherAggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        await domainEventStore.saveEvents({
          uncommittedEvents: [ otherSucceeded, otherExecuted ]
        });

        const useApp = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'useApp',
          data: { otherAggregateId },
          metadata: {
            revision: { aggregate: 3 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        const stop = record(false);

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: useApp });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('useApp');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        const { stdout } = stop();
        const message = JSON.parse(stdout);

        assert.that(message).is.atLeast({
          id: otherAggregateId,
          state: {}
        });
      });

      test('uses the client service.', async (): Promise<void> => {
        const directory = await eventFilter();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const useClient = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
          name: 'useClient',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        const stop = record(false);

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: useClient });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('useClient');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        const { stdout } = stop();
        const message = JSON.parse(stdout);

        assert.that(message).is.atLeast({
          user: {
            id: 'anonymous',
            claims: {
              iss: 'https://token.invalid',
              sub: 'anonymous'
            }
          }
        });
        assert.that(message.ip).is.ofType('string');
        assert.that(message.ip.length).is.atLeast(1);
      });

      for (const logLevel of [ 'fatal', 'error', 'warn', 'info', 'debug' ]) {
        /* eslint-disable no-loop-func */
        test(`uses the logger service with log level '${logLevel}'.`, async (): Promise<void> => {
          const directory = await eventFilter();

          application = await Application.load({ directory });
          repository = new Repository({ application, domainEventStore });

          http = await Http.create({
            corsOrigin: '*',
            purpose: 'external',
            async onReceiveEvent (): Promise<void> {
              // Intentionally left blank.
            },
            application,
            repository,
            identityProviders
          });

          const useLogger = buildDomainEvent({
            contextIdentifier: { name: 'sampleContext' },
            aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
            name: 'useLogger',
            data: { logLevel },
            metadata: {
              revision: { aggregate: 1 },
              initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
            },
            annotations: { state: {}, previousState: {}}
          });

          const stop = record(false);

          setTimeout(async (): Promise<void> => {
            await http.publishDomainEvent({ domainEvent: useLogger });
          }, 50);

          await new Promise((resolve: (value?: unknown) => void, reject): void => {
            try {
              supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
                (domainEvent): void => {
                  assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
                },
                (domainEvent): void => {
                  assert.that(domainEvent.name).is.equalTo('useLogger');
                  resolve();
                }
              ));
            } catch (ex) {
              reject(ex);
            }
          });

          const { stdout } = stop();
          const message = JSON.parse(stdout);

          assert.that(message).is.atLeast({
            level: logLevel,
            message: 'Some log message.',
            source: path.join(directory, '/server/domain/sampleContext/sampleAggregate.js')
          });
        });
        /* eslint-enable no-loop-func */
      }
    });

    suite('map', (): void => {
      test('maps the event.', async (): Promise<void> => {
        const directory = await eventMap();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const mapApplied = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'mapApplied',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: mapApplied });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('mapApplied');
                assert.that(domainEvent.data).is.equalTo({ isMapped: true });
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('skips an event if the event gets filtered out.', async (): Promise<void> => {
        const directory = await eventMap();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const mapDenied = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'mapDenied',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const executed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: mapDenied });
          await http.publishDomainEvent({ domainEvent: executed });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('skips an event if an error is thrown.', async (): Promise<void> => {
        const directory = await eventMap();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const mapFailed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'mapFailed',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const executed = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: mapFailed });
          await http.publishDomainEvent({ domainEvent: executed });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('executed');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });
      });

      test('does not mutate the event.', async (): Promise<void> => {
        const directory = await eventMap();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid();

        const mapAppliedWithMutation = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'mapAppliedWithMutation',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: mapAppliedWithMutation });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('mapAppliedWithMutation');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        assert.that(mapAppliedWithMutation.data.isMutated).is.undefined();
      });

      test('uses the app service.', async (): Promise<void> => {
        const directory = await eventMap();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const aggregateId = uuid(),
              otherAggregateId = uuid();

        const otherSucceeded = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: otherAggregateId },
          name: 'succeeded',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });
        const otherExecuted = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: otherAggregateId },
          name: 'executed',
          data: { strategy: 'succeed' },
          metadata: {
            revision: { aggregate: 2 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        await domainEventStore.saveEvents({
          uncommittedEvents: [ otherSucceeded, otherExecuted ]
        });

        const useApp = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: aggregateId },
          name: 'useApp',
          data: { otherAggregateId },
          metadata: {
            revision: { aggregate: 3 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        const stop = record(false);

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: useApp });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('useApp');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        const { stdout } = stop();
        const message = JSON.parse(stdout);

        assert.that(message).is.atLeast({
          id: otherAggregateId,
          state: {}
        });
      });

      test('uses the client service.', async (): Promise<void> => {
        const directory = await eventMap();

        application = await Application.load({ directory });
        repository = new Repository({ application, domainEventStore });

        http = await Http.create({
          corsOrigin: '*',
          purpose: 'external',
          async onReceiveEvent (): Promise<void> {
            // Intentionally left blank.
          },
          application,
          repository,
          identityProviders
        });

        const useClient = buildDomainEvent({
          contextIdentifier: { name: 'sampleContext' },
          aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
          name: 'useClient',
          metadata: {
            revision: { aggregate: 1 },
            initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
          },
          annotations: { state: {}, previousState: {}}
        });

        const stop = record(false);

        setTimeout(async (): Promise<void> => {
          await http.publishDomainEvent({ domainEvent: useClient });
        }, 50);

        await new Promise((resolve: (value?: unknown) => void, reject): void => {
          try {
            supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
              (domainEvent): void => {
                assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
              },
              (domainEvent): void => {
                assert.that(domainEvent.name).is.equalTo('useClient');
                resolve();
              }
            ));
          } catch (ex) {
            reject(ex);
          }
        });

        const { stdout } = stop();
        const message = JSON.parse(stdout);

        assert.that(message).is.atLeast({
          user: {
            id: 'anonymous',
            claims: {
              iss: 'https://token.invalid',
              sub: 'anonymous'
            }
          }
        });
        assert.that(message.ip).is.ofType('string');
        assert.that(message.ip.length).is.atLeast(1);
      });

      for (const logLevel of [ 'fatal', 'error', 'warn', 'info', 'debug' ]) {
        /* eslint-disable no-loop-func */
        test(`uses the logger service with log level '${logLevel}'.`, async (): Promise<void> => {
          const directory = await eventMap();

          application = await Application.load({ directory });
          repository = new Repository({ application, domainEventStore });

          http = await Http.create({
            corsOrigin: '*',
            purpose: 'external',
            async onReceiveEvent (): Promise<void> {
              // Intentionally left blank.
            },
            application,
            repository,
            identityProviders
          });

          const useLogger = buildDomainEvent({
            contextIdentifier: { name: 'sampleContext' },
            aggregateIdentifier: { name: 'sampleAggregate', id: uuid() },
            name: 'useLogger',
            data: { logLevel },
            metadata: {
              revision: { aggregate: 1 },
              initiator: { user: { id: 'jane.doe', claims: { sub: 'jane.doe' }}}
            },
            annotations: { state: {}, previousState: {}}
          });

          const stop = record(false);

          setTimeout(async (): Promise<void> => {
            await http.publishDomainEvent({ domainEvent: useLogger });
          }, 50);

          await new Promise((resolve: (value?: unknown) => void, reject): void => {
            try {
              supertest(http.api).get('/v2/').pipe(asJsonStream<DomainEvent<DomainEventData>>(
                (domainEvent): void => {
                  assert.that(domainEvent).is.equalTo({ name: 'heartbeat' });
                },
                (domainEvent): void => {
                  assert.that(domainEvent.name).is.equalTo('useLogger');
                  resolve();
                }
              ));
            } catch (ex) {
              reject(ex);
            }
          });

          const { stdout } = stop();
          const message = JSON.parse(stdout);

          assert.that(message).is.atLeast({
            level: logLevel,
            message: 'Some log message.',
            source: path.join(directory, '/server/domain/sampleContext/sampleAggregate.js')
          });
        });
        /* eslint-enable no-loop-func */
      }
    });
  });

  suite('POST /v2/', (): void => {
    let http: Http;

    setup(async (): Promise<void> => {
      http = await Http.create({
        corsOrigin: '*',
        purpose: 'external',
        async onReceiveEvent (): Promise<void> {
          // Intentionally left blank.
        },
        application,
        repository,
        identityProviders
      });
    });

    test('returns a 404.', async (): Promise<void> => {
      const { status } = await supertest(http.api).post('/v2/');

      assert.that(status).is.equalTo(404);
    });
  });
});

suite('internal', (): void => {
  suite('GET /v2/configuration', (): void => {
    let http: Http;

    setup(async (): Promise<void> => {
      http = await Http.create({
        corsOrigin: '*',
        purpose: 'internal',
        onReceiveEvent (): void {
          // Intentionally left blank.
        },
        application,
        repository,
        identityProviders
      });
    });

    test('returns 404.', async (): Promise<void> => {
      await supertest(http.api).
        get('/v2/configuration').
        expect((res: Response): void => {
          assert.that(res.status).is.equalTo(404);
        });
    });
  });

  suite('GET /v2/', (): void => {
    let http: Http;

    setup(async (): Promise<void> => {
      http = await Http.create({
        corsOrigin: '*',
        purpose: 'internal',
        onReceiveEvent (): void {
          // Intentionally left blank.
        },
        application,
        repository,
        identityProviders
      });
    });

    test('returns 404.', async (): Promise<void> => {
      await supertest(http.api).
        get('/v2/').
        expect((res: Response): void => {
          assert.that(res.status).is.equalTo(404);
        });
    });
  });
});
